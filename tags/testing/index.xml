<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Mike Mwita</title><link>https://MikeMwita.github.io/tags/testing/</link><description>Recent content in Testing on Mike Mwita</description><generator>Hugo</generator><language>en</language><copyright>© 2025 Mike Mwita</copyright><lastBuildDate>Tue, 21 Oct 2025 07:00:00 +0300</lastBuildDate><atom:link href="https://MikeMwita.github.io/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Write Once, Test Everywhere: Sharing Common Tests in Python’s unittest</title><link>https://MikeMwita.github.io/thoughts/unit-test/</link><pubDate>Tue, 21 Oct 2025 07:00:00 +0300</pubDate><guid>https://MikeMwita.github.io/thoughts/unit-test/</guid><description>&lt;p>A while back, I was writing tests for a project using Python’s unittest.
Nothing dramatic — just the usual rhythm: write a class, test it, move to the next one.
After a few classes, though, the déjà vu hit.&lt;/p></description></item><item><title>Behavior-Driven Development in Go</title><link>https://MikeMwita.github.io/thoughts/bdd-tests-in-go/</link><pubDate>Tue, 12 May 2020 07:00:22 +0300</pubDate><guid>https://MikeMwita.github.io/thoughts/bdd-tests-in-go/</guid><description>&lt;p>Testing is often seen as a technical safeguard — a way to ensure code correctness.
But what if tests could do more than that?
What if they could express intent, document behavior, and communicate meaning across developers, testers, and product owners alike?&lt;/p></description></item></channel></rss>